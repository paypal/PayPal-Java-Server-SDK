/*
 * PaypalServerSdkLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.paypal.sdk.controllers;

import com.paypal.sdk.ApiHelper;
import com.paypal.sdk.Server;
import com.paypal.sdk.exceptions.ApiException;
import com.paypal.sdk.exceptions.SubscriptionErrorException;
import com.paypal.sdk.http.request.HttpMethod;
import com.paypal.sdk.http.response.ApiResponse;
import com.paypal.sdk.models.ActivateSubscriptionInput;
import com.paypal.sdk.models.BillingPlan;
import com.paypal.sdk.models.CancelSubscriptionInput;
import com.paypal.sdk.models.CaptureSubscriptionInput;
import com.paypal.sdk.models.CreateBillingPlanInput;
import com.paypal.sdk.models.CreateSubscriptionInput;
import com.paypal.sdk.models.GetSubscriptionInput;
import com.paypal.sdk.models.ListBillingPlansInput;
import com.paypal.sdk.models.ListSubscriptionTransactionsInput;
import com.paypal.sdk.models.ListSubscriptionsInput;
import com.paypal.sdk.models.ModifySubscriptionResponse;
import com.paypal.sdk.models.PatchBillingPlanInput;
import com.paypal.sdk.models.PatchSubscriptionInput;
import com.paypal.sdk.models.PlanCollection;
import com.paypal.sdk.models.ReviseSubscriptionInput;
import com.paypal.sdk.models.Subscription;
import com.paypal.sdk.models.SubscriptionCollection;
import com.paypal.sdk.models.SubscriptionTransactionDetails;
import com.paypal.sdk.models.SuspendSubscriptionInput;
import com.paypal.sdk.models.TransactionsList;
import com.paypal.sdk.models.UpdateBillingPlanPricingSchemesInput;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import io.apimatic.coreinterfaces.http.request.ResponseClassType;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class SubscriptionsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public SubscriptionsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Creates a plan that defines pricing and billing cycle details for subscriptions.
     * @param  input  CreateBillingPlanInput object containing request parameters
     * @return    Returns the BillingPlan wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<BillingPlan> createBillingPlan(
            final CreateBillingPlanInput input) throws ApiException, IOException {
        return prepareCreateBillingPlanRequest(input).execute();
    }

    /**
     * Creates a plan that defines pricing and billing cycle details for subscriptions.
     * @param  input  CreateBillingPlanInput object containing request parameters
     * @return    Returns the BillingPlan wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<BillingPlan>> createBillingPlanAsync(
            final CreateBillingPlanInput input) {
        try {
            return prepareCreateBillingPlanRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for createBillingPlan.
     */
    private ApiCall<ApiResponse<BillingPlan>, ApiException> prepareCreateBillingPlanRequest(
            final CreateBillingPlanInput input) {
        return new ApiCall.Builder<ApiResponse<BillingPlan>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("Prefer")
                                .value(input.getPrefer()).isRequired(false))
                        .headerParam(param -> param.key("PayPal-Request-Id")
                                .value(input.getPaypalRequestId()).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, BillingPlan.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists billing plans.
     * @param  input  ListBillingPlansInput object containing request parameters
     * @return    Returns the PlanCollection wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<PlanCollection> listBillingPlans(
            final ListBillingPlansInput input) throws ApiException, IOException {
        return prepareListBillingPlansRequest(input).execute();
    }

    /**
     * Lists billing plans.
     * @param  input  ListBillingPlansInput object containing request parameters
     * @return    Returns the PlanCollection wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<PlanCollection>> listBillingPlansAsync(
            final ListBillingPlansInput input) {
        try {
            return prepareListBillingPlansRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for listBillingPlans.
     */
    private ApiCall<ApiResponse<PlanCollection>, ApiException> prepareListBillingPlansRequest(
            final ListBillingPlansInput input) {
        return new ApiCall.Builder<ApiResponse<PlanCollection>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans")
                        .queryParam(param -> param.key("product_id")
                                .value(input.getProductId()).isRequired(false))
                        .queryParam(param -> param.key("page_size")
                                .value(input.getPageSize()).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value(input.getPage()).isRequired(false))
                        .queryParam(param -> param.key("total_required")
                                .value(input.getTotalRequired()).isRequired(false))
                        .headerParam(param -> param.key("Prefer")
                                .value(input.getPrefer()).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, PlanCollection.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Shows details for a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the BillingPlan wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<BillingPlan> getBillingPlan(
            final String id) throws ApiException, IOException {
        return prepareGetBillingPlanRequest(id).execute();
    }

    /**
     * Shows details for a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the BillingPlan wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<BillingPlan>> getBillingPlanAsync(
            final String id) {
        try {
            return prepareGetBillingPlanRequest(id).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for getBillingPlan.
     */
    private ApiCall<ApiResponse<BillingPlan>, ApiException> prepareGetBillingPlanRequest(
            final String id) {
        return new ApiCall.Builder<ApiResponse<BillingPlan>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans/{id}")
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, BillingPlan.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a plan with the `CREATED` or `ACTIVE` status. For an `INACTIVE` plan, you can make
     * only status updates. You can patch these attributes and objects: Attribute or object
     * Operations description replace payment_preferences.auto_bill_outstanding replace
     * taxes.percentage replace payment_preferences.payment_failure_threshold replace
     * payment_preferences.setup_fee replace payment_preferences.setup_fee_failure_action replace
     * name replace.
     * @param  input  PatchBillingPlanInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> patchBillingPlan(
            final PatchBillingPlanInput input) throws ApiException, IOException {
        return preparePatchBillingPlanRequest(input).execute();
    }

    /**
     * Updates a plan with the `CREATED` or `ACTIVE` status. For an `INACTIVE` plan, you can make
     * only status updates. You can patch these attributes and objects: Attribute or object
     * Operations description replace payment_preferences.auto_bill_outstanding replace
     * taxes.percentage replace payment_preferences.payment_failure_threshold replace
     * payment_preferences.setup_fee replace payment_preferences.setup_fee_failure_action replace
     * name replace.
     * @param  input  PatchBillingPlanInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> patchBillingPlanAsync(
            final PatchBillingPlanInput input) {
        try {
            return preparePatchBillingPlanRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for patchBillingPlan.
     */
    private ApiCall<ApiResponse<Void>, ApiException> preparePatchBillingPlanRequest(
            final PatchBillingPlanInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans/{id}")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Activates a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> activateBillingPlan(
            final String id) throws ApiException, IOException {
        return prepareActivateBillingPlanRequest(id).execute();
    }

    /**
     * Activates a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> activateBillingPlanAsync(
            final String id) {
        try {
            return prepareActivateBillingPlanRequest(id).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for activateBillingPlan.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareActivateBillingPlanRequest(
            final String id) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans/{id}/activate")
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deactivates a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> deactivateBillingPlan(
            final String id) throws ApiException, IOException {
        return prepareDeactivateBillingPlanRequest(id).execute();
    }

    /**
     * Deactivates a plan, by ID.
     * @param  id  Required parameter: The ID of the plan.
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> deactivateBillingPlanAsync(
            final String id) {
        try {
            return prepareDeactivateBillingPlanRequest(id).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for deactivateBillingPlan.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareDeactivateBillingPlanRequest(
            final String id) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans/{id}/deactivate")
                        .templateParam(param -> param.key("id").value(id)
                                .shouldEncode(true))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates pricing for a plan. For example, you can update a regular billing cycle from $5 per
     * month to $7 per month.
     * @param  input  UpdateBillingPlanPricingSchemesInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> updateBillingPlanPricingSchemes(
            final UpdateBillingPlanPricingSchemesInput input) throws ApiException, IOException {
        return prepareUpdateBillingPlanPricingSchemesRequest(input).execute();
    }

    /**
     * Updates pricing for a plan. For example, you can update a regular billing cycle from $5 per
     * month to $7 per month.
     * @param  input  UpdateBillingPlanPricingSchemesInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> updateBillingPlanPricingSchemesAsync(
            final UpdateBillingPlanPricingSchemesInput input) {
        try {
            return prepareUpdateBillingPlanPricingSchemesRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for updateBillingPlanPricingSchemes.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareUpdateBillingPlanPricingSchemesRequest(
            final UpdateBillingPlanPricingSchemesInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/plans/{id}/update-pricing-schemes")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a subscription.
     * @param  input  CreateSubscriptionInput object containing request parameters
     * @return    Returns the Subscription wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Subscription> createSubscription(
            final CreateSubscriptionInput input) throws ApiException, IOException {
        return prepareCreateSubscriptionRequest(input).execute();
    }

    /**
     * Creates a subscription.
     * @param  input  CreateSubscriptionInput object containing request parameters
     * @return    Returns the Subscription wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Subscription>> createSubscriptionAsync(
            final CreateSubscriptionInput input) {
        try {
            return prepareCreateSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for createSubscription.
     */
    private ApiCall<ApiResponse<Subscription>, ApiException> prepareCreateSubscriptionRequest(
            final CreateSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Subscription>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("Prefer")
                                .value(input.getPrefer()).isRequired(false))
                        .headerParam(param -> param.key("PayPal-Request-Id")
                                .value(input.getPaypalRequestId()).isRequired(false))
                        .headerParam(param -> param.key("PayPal-Client-Metadata-Id")
                                .value(input.getPaypalClientMetadataId()).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, Subscription.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all subscriptions for merchant account.
     * @param  input  ListSubscriptionsInput object containing request parameters
     * @return    Returns the SubscriptionCollection wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<SubscriptionCollection> listSubscriptions(
            final ListSubscriptionsInput input) throws ApiException, IOException {
        return prepareListSubscriptionsRequest(input).execute();
    }

    /**
     * List all subscriptions for merchant account.
     * @param  input  ListSubscriptionsInput object containing request parameters
     * @return    Returns the SubscriptionCollection wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<SubscriptionCollection>> listSubscriptionsAsync(
            final ListSubscriptionsInput input) {
        try {
            return prepareListSubscriptionsRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for listSubscriptions.
     */
    private ApiCall<ApiResponse<SubscriptionCollection>, ApiException> prepareListSubscriptionsRequest(
            final ListSubscriptionsInput input) {
        return new ApiCall.Builder<ApiResponse<SubscriptionCollection>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions")
                        .queryParam(param -> param.key("plan_ids")
                                .value(input.getPlanIds()).isRequired(false))
                        .queryParam(param -> param.key("statuses")
                                .value(input.getStatuses()).isRequired(false))
                        .queryParam(param -> param.key("created_after")
                                .value(input.getCreatedAfter()).isRequired(false))
                        .queryParam(param -> param.key("created_before")
                                .value(input.getCreatedBefore()).isRequired(false))
                        .queryParam(param -> param.key("status_updated_before")
                                .value(input.getStatusUpdatedBefore()).isRequired(false))
                        .queryParam(param -> param.key("status_updated_after")
                                .value(input.getStatusUpdatedAfter()).isRequired(false))
                        .queryParam(param -> param.key("filter")
                                .value(input.getFilter()).isRequired(false))
                        .queryParam(param -> param.key("page_size")
                                .value(input.getPageSize()).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value(input.getPage()).isRequired(false))
                        .queryParam(param -> param.key("customer_ids")
                                .value(input.getCustomerIds()).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionCollection.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Shows details for a subscription, by ID.
     * @param  input  GetSubscriptionInput object containing request parameters
     * @return    Returns the Subscription wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Subscription> getSubscription(
            final GetSubscriptionInput input) throws ApiException, IOException {
        return prepareGetSubscriptionRequest(input).execute();
    }

    /**
     * Shows details for a subscription, by ID.
     * @param  input  GetSubscriptionInput object containing request parameters
     * @return    Returns the Subscription wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Subscription>> getSubscriptionAsync(
            final GetSubscriptionInput input) {
        try {
            return prepareGetSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for getSubscription.
     */
    private ApiCall<ApiResponse<Subscription>, ApiException> prepareGetSubscriptionRequest(
            final GetSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Subscription>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}")
                        .queryParam(param -> param.key("fields")
                                .value(input.getFields()).isRequired(false))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, Subscription.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a subscription which could be in ACTIVE or SUSPENDED status. You can override plan
     * level default attributes by providing customised values for plan path in the patch request.
     * You cannot update attributes that have already completed (Example - trial cycles can’t be
     * updated if completed). Once overridden, changes to plan resource will not impact
     * subscription. Any price update will not impact billing cycles within next 10 days (Applicable
     * only for subscriptions funded by PayPal account). Following are the fields eligible for
     * patch. Attribute or object Operations billing_info.outstanding_balance replace custom_id
     * add,replace plan.billing_cycles[{@literal @}sequence==n]. pricing_scheme.fixed_price add,replace
     * plan.billing_cycles[{@literal @}sequence==n]. pricing_scheme.tiers replace
     * plan.billing_cycles[{@literal @}sequence==n]. total_cycles replace plan.payment_preferences.
     * auto_bill_outstanding replace plan.payment_preferences. payment_failure_threshold replace
     * plan.taxes.inclusive add,replace plan.taxes.percentage add,replace shipping_amount
     * add,replace start_time replace subscriber.shipping_address add,replace
     * subscriber.payment_source (for subscriptions funded by card payments) replace.
     * @param  input  PatchSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> patchSubscription(
            final PatchSubscriptionInput input) throws ApiException, IOException {
        return preparePatchSubscriptionRequest(input).execute();
    }

    /**
     * Updates a subscription which could be in ACTIVE or SUSPENDED status. You can override plan
     * level default attributes by providing customised values for plan path in the patch request.
     * You cannot update attributes that have already completed (Example - trial cycles can’t be
     * updated if completed). Once overridden, changes to plan resource will not impact
     * subscription. Any price update will not impact billing cycles within next 10 days (Applicable
     * only for subscriptions funded by PayPal account). Following are the fields eligible for
     * patch. Attribute or object Operations billing_info.outstanding_balance replace custom_id
     * add,replace plan.billing_cycles[{@literal @}sequence==n]. pricing_scheme.fixed_price add,replace
     * plan.billing_cycles[{@literal @}sequence==n]. pricing_scheme.tiers replace
     * plan.billing_cycles[{@literal @}sequence==n]. total_cycles replace plan.payment_preferences.
     * auto_bill_outstanding replace plan.payment_preferences. payment_failure_threshold replace
     * plan.taxes.inclusive add,replace plan.taxes.percentage add,replace shipping_amount
     * add,replace start_time replace subscriber.shipping_address add,replace
     * subscriber.payment_source (for subscriptions funded by card payments) replace.
     * @param  input  PatchSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> patchSubscriptionAsync(
            final PatchSubscriptionInput input) {
        try {
            return preparePatchSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for patchSubscription.
     */
    private ApiCall<ApiResponse<Void>, ApiException> preparePatchSubscriptionRequest(
            final PatchSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates the quantity of the product or service in a subscription. You can also use this
     * method to switch the plan and update the `shipping_amount`, `shipping_address` values for the
     * subscription. This type of update requires the buyer's consent.
     * @param  input  ReviseSubscriptionInput object containing request parameters
     * @return    Returns the ModifySubscriptionResponse wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ModifySubscriptionResponse> reviseSubscription(
            final ReviseSubscriptionInput input) throws ApiException, IOException {
        return prepareReviseSubscriptionRequest(input).execute();
    }

    /**
     * Updates the quantity of the product or service in a subscription. You can also use this
     * method to switch the plan and update the `shipping_amount`, `shipping_address` values for the
     * subscription. This type of update requires the buyer's consent.
     * @param  input  ReviseSubscriptionInput object containing request parameters
     * @return    Returns the ModifySubscriptionResponse wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ModifySubscriptionResponse>> reviseSubscriptionAsync(
            final ReviseSubscriptionInput input) {
        try {
            return prepareReviseSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for reviseSubscription.
     */
    private ApiCall<ApiResponse<ModifySubscriptionResponse>, ApiException> prepareReviseSubscriptionRequest(
            final ReviseSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<ModifySubscriptionResponse>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/revise")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ModifySubscriptionResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Suspends the subscription.
     * @param  input  SuspendSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> suspendSubscription(
            final SuspendSubscriptionInput input) throws ApiException, IOException {
        return prepareSuspendSubscriptionRequest(input).execute();
    }

    /**
     * Suspends the subscription.
     * @param  input  SuspendSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> suspendSubscriptionAsync(
            final SuspendSubscriptionInput input) {
        try {
            return prepareSuspendSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for suspendSubscription.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareSuspendSubscriptionRequest(
            final SuspendSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/suspend")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Cancels the subscription.
     * @param  input  CancelSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> cancelSubscription(
            final CancelSubscriptionInput input) throws ApiException, IOException {
        return prepareCancelSubscriptionRequest(input).execute();
    }

    /**
     * Cancels the subscription.
     * @param  input  CancelSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> cancelSubscriptionAsync(
            final CancelSubscriptionInput input) {
        try {
            return prepareCancelSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for cancelSubscription.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareCancelSubscriptionRequest(
            final CancelSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/cancel")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Activates the subscription.
     * @param  input  ActivateSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<Void> activateSubscription(
            final ActivateSubscriptionInput input) throws ApiException, IOException {
        return prepareActivateSubscriptionRequest(input).execute();
    }

    /**
     * Activates the subscription.
     * @param  input  ActivateSubscriptionInput object containing request parameters
     * @return    Returns the Void wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<Void>> activateSubscriptionAsync(
            final ActivateSubscriptionInput input) {
        try {
            return prepareActivateSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for activateSubscription.
     */
    private ApiCall<ApiResponse<Void>, ApiException> prepareActivateSubscriptionRequest(
            final ActivateSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<Void>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/activate")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Captures an authorized payment from the subscriber on the subscription.
     * @param  input  CaptureSubscriptionInput object containing request parameters
     * @return    Returns the SubscriptionTransactionDetails wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<SubscriptionTransactionDetails> captureSubscription(
            final CaptureSubscriptionInput input) throws ApiException, IOException {
        return prepareCaptureSubscriptionRequest(input).execute();
    }

    /**
     * Captures an authorized payment from the subscriber on the subscription.
     * @param  input  CaptureSubscriptionInput object containing request parameters
     * @return    Returns the SubscriptionTransactionDetails wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<SubscriptionTransactionDetails>> captureSubscriptionAsync(
            final CaptureSubscriptionInput input) {
        try {
            return prepareCaptureSubscriptionRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for captureSubscription.
     */
    private ApiCall<ApiResponse<SubscriptionTransactionDetails>, ApiException> prepareCaptureSubscriptionRequest(
            final CaptureSubscriptionInput input) {
        return new ApiCall.Builder<ApiResponse<SubscriptionTransactionDetails>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/capture")
                        .bodyParam(param -> param.value(input.getBody()).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(input.getBody()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("PayPal-Request-Id")
                                .value(input.getPaypalRequestId()).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, SubscriptionTransactionDetails.class))
                        .nullableResponseType(true)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.setReason("The requested action could not be performed, semantically incorrect, or failed business validation.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists transactions for a subscription.
     * @param  input  ListSubscriptionTransactionsInput object containing request parameters
     * @return    Returns the TransactionsList wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<TransactionsList> listSubscriptionTransactions(
            final ListSubscriptionTransactionsInput input) throws ApiException, IOException {
        return prepareListSubscriptionTransactionsRequest(input).execute();
    }

    /**
     * Lists transactions for a subscription.
     * @param  input  ListSubscriptionTransactionsInput object containing request parameters
     * @return    Returns the TransactionsList wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<TransactionsList>> listSubscriptionTransactionsAsync(
            final ListSubscriptionTransactionsInput input) {
        try {
            return prepareListSubscriptionTransactionsRequest(input).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for listSubscriptionTransactions.
     */
    private ApiCall<ApiResponse<TransactionsList>, ApiException> prepareListSubscriptionTransactionsRequest(
            final ListSubscriptionTransactionsInput input) {
        return new ApiCall.Builder<ApiResponse<TransactionsList>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/v1/billing/subscriptions/{id}/transactions")
                        .queryParam(param -> param.key("start_time")
                                .value(input.getStartTime()))
                        .queryParam(param -> param.key("end_time")
                                .value(input.getEndTime()))
                        .templateParam(param -> param.key("id").value(input.getId())
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("Oauth2"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, TransactionsList.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("Bad Request. Request is not well-formed, syntactically incorrect, or violates schema.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("Authentication failed due to missing authorization header, or invalid authentication credentials.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Authorization failed due to insufficient permissions.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The specified resource does not exist.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("An internal server error has occurred.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("The error response.",
                                (reason, context) -> new SubscriptionErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}